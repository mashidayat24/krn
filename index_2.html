<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VKRN ULP Wonosobo</title>
    <!-- Load PDF.js library for rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        /* General styling for the page */
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        /* Styles for the initialization overlay */
        .initialization-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .initialization-content {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            max-width: 450px;
            width: 90%;
        }
        .init-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid #ecf0f1;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        .init-text {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .init-subtext {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-fill {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-text {
            font-size: 12px;
            color: #7f8c8d;
        }
        .first-time-notice {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #856404;
        }
        /* Search and button styling */
        .search-container {
            display: flex;
            margin-bottom: 20px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .search-container.hidden {
            display: none;
        }
        #searchInput {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px 0 0 5px;
            font-size: 16px;
            outline: none;
        }
        #searchInput:focus {
            border-color: #3498db;
        }
        #searchButton {
            padding: 12px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 0 5px 5px 0;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        #searchButton:hover {
            background-color: #2980b9;
        }
        .search-again-container {
            display: none;
            text-align: center;
            margin-bottom: 20px;
        }
        .search-again-container.show {
            display: block;
        }
        .search-again-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .search-again-btn:hover {
            background-color: #c0392b;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .system-status {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 12px 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            display: none;
        }
        .system-status.show {
            display: block;
        }
        .system-status.error {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .system-status.cached {
            background-color: #d1ecf1;
            border-color: #bee5eb;
            color: #0c5460;
        }
        .database-controls {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            display: none;
        }
        .database-controls.show {
            display: block;
        }
        .database-info {
            font-size: 13px;
            color: #6c757d;
            margin-bottom: 10px;
        }
        .refresh-db-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        .refresh-db-btn:hover {
            background-color: #545b62;
        }
        #resultsContainer {
            margin-top: 20px;
            margin-bottom: 30px;
        }
        /* Style for search results */
        .result-item {
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 15px;
            background-color: #fafafa;
            display: inline-block;
            width: calc(50% - 10px);
            margin-right: 20px;
            vertical-align: top;
        }
        .result-item:nth-child(even) {
            margin-right: 0;
        }
        .result-item p {
            margin: 5px 0;
            word-wrap: break-word;
            font-size: 14px;
        }
        .result-item strong {
            color: #2c3e50;
        }
        .result-item .idpel {
            background-color: #e8f6ff;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
            margin: 10px 0;
            font-weight: bold;
        }
        .no-results {
            text-align: center;
            color: #7f8c8d;
            padding: 20px;
        }
        .show-program-btn {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 10px;
            width: 100%;
        }
        .show-program-btn:hover {
            background-color: #229954;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .show-program-btn.instant {
            background-color: #f39c12;
            position: relative;
        }
        .show-program-btn.instant:hover {
            background-color: #d68910;
        }
        .show-program-btn.instant::after {
            content: "⚡";
            position: absolute;
            top: 2px;
            right: 5px;
            font-size: 12px;
        }
        /* PDF viewer styling */
        #pdfContainer {
            display: none;
            margin-top: 30px;
            border-top: 2px solid #34495e;
            padding-top: 30px;
        }
        .pdf-viewer {
            background-color: white;
            text-align: center;
            padding: 0;
        }
        .pdf-page {
            margin-bottom: 20px;
            position: relative;
            display: inline-block;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .pdf-canvas {
            width: 100%;
            height: auto;
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        /* Text highlighting on the PDF pages */
        .highlight-overlay {
            position: absolute;
            background-color: rgba(255, 255, 0, 0.4);
            border: 2px solid #ffeb3b;
            border-radius: 3px;
            pointer-events: none;
            animation: blink 1.5s ease-in-out 3;
        }
        @keyframes blink {
            0%, 100% {
                opacity: 0.4;
            }
            50% {
                opacity: 0.8;
            }
        }
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        .results-count {
            margin-bottom: 15px;
            color: #7f8c8d;
            font-size: 14px;
            font-weight: bold;
        }

        /* Styles for location and comments section */
        .location-section {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #f8f9fa;
        }
        .location-section.hidden {
            display: none;
        }
        .location-section h2 {
            margin-top: 0;
            color: #34495e;
            text-align: center;
        }
        .location-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        .location-form textarea {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            resize: vertical;
        }
        .location-form button {
            padding: 12px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        .location-form button:hover {
            background-color: #2980b9;
        }
        #locationStatus {
            font-size: 14px;
            font-style: italic;
            color: #555;
            text-align: center;
        }
        /* Modal for alerts */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 400px;
            border-radius: 10px;
            text-align: center;
        }
        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .modal-close:hover,
        .modal-close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            .result-item {
                width: 100%;
                margin-right: 0;
            }
            .initialization-content {
                padding: 30px 20px;
            }
            .search-container {
                max-width: 100%;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>

    <!-- Modal for alerts -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
        </div>
    </div>

    <!-- Overlay for system initialization -->
    <div class="initialization-overlay" id="initOverlay">
        <div class="initialization-content">
            <div class="init-spinner"></div>
            <div class="init-text" id="initTitle">Memuat Sistem Pencarian</div>
            <div class="init-subtext" id="initSubtext">Mohon tunggu...</div>
            <div class="first-time-notice" id="firstTimeNotice" style="display: none;">
                📝 <strong>Informasi:</strong> Ini adalah kunjungan pertama Anda. Sistem sedang membangun database lokal untuk pencarian yang lebih cepat di kunjungan selanjutnya.
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">0% - Memuat...</div>
        </div>
    </div>

    <div class="container">
        <h1>VKRN ULP Wonosobo</h1>

        <!-- System status messages -->
        <div class="system-status" id="systemStatus">
            ✅ Sistem siap!
        </div>

        <!-- Database refresh controls -->
        <div class="database-controls" id="databaseControls">
            <div class="database-info" id="databaseInfo">
                Database terakhir diupdate: <span id="lastUpdate">-</span>
            </div>
            <button class="refresh-db-btn" onclick="refreshDatabase()">
                🔄 Refresh Database
            </button>
        </div>

        <!-- Initial search input container -->
        <div class="search-container" id="searchContainer">
            <input type="text" id="searchInput" placeholder="Masukkan pencarian...">
            <button id="searchButton">Cari</button>
        </div>

        <!-- "Search Again" button container -->
        <div class="search-again-container" id="searchAgainContainer">
            <button class="search-again-btn" id="searchAgainBtn">🔍 Cari Lagi</button>
        </div>

        <div id="resultsContainer"></div>

        <div id="pdfContainer">
            <div class="pdf-viewer" id="pdfViewer"></div>
        </div>

        <hr>

        <!-- New section for location and comments -->
        <!-- Added 'hidden' class to initially hide this section -->
        <div class="location-section hidden" id="locationSection">
            <h2>Simpan Komentar & Lokasi</h2>
            <div class="location-form">
                <textarea id="commentInput" placeholder="Tambahkan komentar Anda di sini..."></textarea>
                <button onclick="saveCommentAndLocation()">Simpan</button>
            </div>
            <p id="locationStatus"></p>
        </div>

    </div>

    <script>
        // Global variables for the application state
        let csvData = [];
        let currentPdf = null;
        let searchIdpel = '';
        let foundPages = [];
        let devicePixelRatio = window.devicePixelRatio || 1;
        let hasSearchResults = false;
        let isSystemReady = false;
        let isSaving = false;

        // IndexedDB variables for local database storage
        let db = null;
        let textIndex = new Map(); // In-memory cache of the PDF text index
        let pdfDatabase = new Map(); // In-memory cache of PDF objects
        
        // IndexedDB configuration
        const DATABASE_NAME = 'VKRNPDFDatabase';
        const DATABASE_VERSION = 3; // Increment version to trigger onupgradeneeded for new stores
        const DATABASE_STORE_PDF = 'pdfTextIndex';
        const DATABASE_STORE_CSV = 'customerData';
        const DATABASE_EXPIRY_DAYS = 30; // Database expires after 30 days

        // This is a simple, 1-page placeholder PDF encoded as a base64 string.
        const placeholderPdfBase64 = 'JVBERi0xLjQKJcOkw7zEnzUKMSAwIG9iajw8L1BhZ2VzIDIgMCBSL1R5cGUvQ2F0YWxvZz4+CmVuZG9iagoyIDAgb2JqPDwvQ291bnQgMS9LaWRzWzMgMCBSXS9UeXBlL1BhZ2VzPj4KZW5kb2JqCjMgMCBvYmo8PC9NZWRpYUJveFswIDAgNTk1IDg0Ml0vUGFyZW50IDIgMCBSL1R5cGUvUGFnZT4+CmVuZG9iagp0cmFpbGVyPDwvUm9vdCAxIDAgUi9TaXplIDQ+Pj4+CiUlRU9G';

        // List of available PDF files to index. The `file` property is replaced with `base64`.
        const availablePDFs = [
            { 
                base64: placeholderPdfBase64,
                name: 'CR PK TOKEN LPB Kolektif KRN KEJAJAR',
                id: 'pdf1'
            },
            { 
                base64: placeholderPdfBase64,
                name: 'KRN KEJAJAR',
                id: 'pdf2'
            },
            { 
                base64: placeholderPdfBase64,
                name: 'KRN KEJAJAR 160824',
                id: 'pdf3'
            },
            { 
                base64: placeholderPdfBase64,
                name: 'TOKEN JAMAL 160824',
                id: 'pdf4'
            }
        ];

        // Hardcoded CSV data with new "Komentar" and "Lokasi" columns.
        const defaultCsvText = `IDPEL,Nama,Alamat,Program,Komentar,Lokasi
987654321,Budi Santoso,Jl. Pahlawan No. 5,Program Subsidi,,
123456789,Siti Aminah,Jl. Merdeka No. 10,Program Reguler,,
112233445,Agus Salim,Jl. Diponegoro No. 22,Program Bisnis,,
556677889,Dewi Lestari,Jl. Kenanga No. 7,Program Subsidi,,
998877665,Rudi Hartono,Jl. Sudirman No. 45,Program Reguler,,
121314151,Eka Putra,Jl. Majapahit No. 101,Program Bisnis,,
232425262,Wati Susanti,Jl. Kartini No. 8,Program Subsidi,,
343536373,Fajar Nugraha,Jl. Gajah Mada No. 33,Program Reguler,,
454647484,Ani Suryani,Jl. Thamrin No. 90,Program Bisnis,,
565758595,Joko Widodo,Jl. Imam Bonjol No. 1,Program Subsidi,,`;
        
        // Set up PDF.js worker to run in the background
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        /**
         * Opens or creates an IndexedDB database for caching the PDF text index.
         * @returns {Promise<IDBDatabase>} A promise that resolves with the database instance.
         */
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                
                request.onerror = () => {
                    console.error('Error opening database:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('Database opened successfully');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    
                    // Remove old object stores if they exist and create new ones
                    if (database.objectStoreNames.contains(DATABASE_STORE_PDF)) {
                        database.deleteObjectStore(DATABASE_STORE_PDF);
                    }
                    if (database.objectStoreNames.contains(DATABASE_STORE_CSV)) {
                        database.deleteObjectStore(DATABASE_STORE_CSV);
                    }
                    
                    // Create object store for PDF index
                    const pdfStore = database.createObjectStore(DATABASE_STORE_PDF, {
                        keyPath: 'id',
                        autoIncrement: true
                    });
                    pdfStore.createIndex('pdfId', 'pdfId', { unique: false });
                    pdfStore.createIndex('pageNumber', 'pageNumber', { unique: false });
                    pdfStore.createIndex('searchText', 'searchText', { unique: false });

                    // Create object store for customer CSV data
                    const csvStore = database.createObjectStore(DATABASE_STORE_CSV, {
                        keyPath: 'id',
                        autoIncrement: true
                    });
                    
                    console.log('Database upgraded successfully');
                };
            });
        }

        /**
         * Saves the in-memory customer data to IndexedDB.
         * @param {Array<object>} data The customer data array to save.
         * @returns {Promise<void>} A promise that resolves when the save is complete.
         */
        function saveCustomerDataToDatabase(data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([DATABASE_STORE_CSV], 'readwrite');
                const store = transaction.objectStore(DATABASE_STORE_CSV);

                const clearRequest = store.clear();
                clearRequest.onsuccess = () => {
                    const addRequest = store.add({
                        type: 'csvData',
                        data: data,
                        timestamp: Date.now()
                    });
                    addRequest.onsuccess = () => {
                        console.log('Customer data saved to IndexedDB.');
                        resolve();
                    };
                    addRequest.onerror = () => reject(addRequest.error);
                };
                clearRequest.onerror = () => reject(clearRequest.error);
            });
        }

        /**
         * Loads customer data from IndexedDB.
         * @returns {Promise<Array<object>|null>} A promise that resolves with the data or null if not found.
         */
        function loadCustomerDataFromDatabase() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([DATABASE_STORE_CSV], 'readonly');
                const store = transaction.objectStore(DATABASE_STORE_CSV);
                const getRequest = store.get(1); // Assuming we only save one object with key 1

                getRequest.onsuccess = () => {
                    const result = getRequest.result;
                    if (result && result.data) {
                        console.log('Customer data loaded from IndexedDB.');
                        resolve(result.data);
                    } else {
                        console.log('No customer data found in IndexedDB.');
                        resolve(null);
                    }
                };
                getRequest.onerror = () => reject(getRequest.error);
            });
        }

        /**
         * Saves the in-memory text index to the IndexedDB database.
         * @param {Map<string, object>} indexData The map containing the indexed data.
         * @returns {Promise<void>} A promise that resolves when the save operation is complete.
         */
        async function saveIndexToDatabase(indexData) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([DATABASE_STORE_PDF], 'readwrite');
                const objectStore = transaction.objectStore(DATABASE_STORE_PDF);
                
                // Clear old data
                const clearRequest = objectStore.clear();

                clearRequest.onsuccess = () => {
                    // Save metadata (timestamp, version, etc.)
                    const metadataRequest = objectStore.add({
                        type: 'metadata',
                        timestamp: Date.now(),
                        version: DATABASE_VERSION,
                        totalPDFs: availablePDFs.length,
                        totalPages: indexData.size
                    });

                    // Save all index entries
                    const promises = [];
                    for (const [key, value] of indexData.entries()) {
                        const request = objectStore.add({
                            type: 'index',
                            indexKey: key,
                            pdfId: value.pdfId,
                            pdfInfo: value.pdfInfo,
                            pageNumber: value.pageNumber,
                            searchText: value.text,
                            originalText: value.originalText
                        });
                        promises.push(new Promise(resolve => request.onsuccess = resolve));
                    }

                    Promise.all(promises).then(() => {
                        console.log('Index saved to IndexedDB successfully');
                        resolve();
                    });
                };
                clearRequest.onerror = () => {
                    console.error('Error clearing database:', clearRequest.error);
                    reject(clearRequest.error);
                };
            });
        }

        /**
         * Loads the text index from the IndexedDB database into memory.
         * @returns {Promise<boolean>} A promise that resolves to true if the cache is valid, false otherwise.
         */
        async function loadIndexFromDatabase() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([DATABASE_STORE_PDF], 'readonly');
                const objectStore = transaction.objectStore(DATABASE_STORE_PDF);
                const getAllRequest = objectStore.getAll();

                getAllRequest.onsuccess = () => {
                    const allData = getAllRequest.result;

                    // Find the metadata entry
                    const metadata = allData.find(item => item.type === 'metadata');

                    if (!metadata) {
                        console.log('No metadata found in database');
                        resolve(false);
                        return;
                    }

                    // Check if the cache is expired
                    const age = Date.now() - metadata.timestamp;
                    const maxAge = DATABASE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;

                    if (age > maxAge) {
                        console.log('Database expired, need refresh');
                        resolve(false);
                        return;
                    }

                    // Load index data into the in-memory Map
                    const indexData = allData.filter(item => item.type === 'index');
                    textIndex.clear();

                    for (const item of indexData) {
                        textIndex.set(item.indexKey, {
                            pdfId: item.pdfId,
                            pdfInfo: item.pdfInfo,
                            pageNumber: item.pageNumber,
                            text: item.searchText,
                            originalText: item.originalText
                        });
                    }

                    console.log(`Loaded ${indexData.length} index entries from database`);

                    // Update the UI with database info
                    updateDatabaseInfo(metadata.timestamp);

                    resolve(true);
                };
                // FIX: Correct the typo from getRequest to getAllRequest
                getAllRequest.onerror = () => {
                    console.error('Error loading from database:', getAllRequest.error);
                    reject(getAllRequest.error);
                };
            });
        }

        // Updates the progress bar during initialization
        function updateProgress(percentage, text) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `${percentage}% - ${text}`;
        }

        // Updates the UI with the last database update time
        function updateDatabaseInfo(timestamp) {
            const lastUpdateElement = document.getElementById('lastUpdate');
            const databaseControlsElement = document.getElementById('databaseControls');

            if (timestamp) {
                const date = new Date(timestamp);
                lastUpdateElement.textContent = date.toLocaleString('id-ID');
                databaseControlsElement.classList.add('show');
            }
        }

        // Displays a system status message
        function showSystemStatus(message, type = 'success') {
            const systemStatus = document.getElementById('systemStatus');
            systemStatus.textContent = message;

            systemStatus.className = 'system-status show';
            if (type === 'error') {
                systemStatus.classList.add('error');
            } else if (type === 'cached') {
                systemStatus.classList.add('cached');
            }

            if (type !== 'error') {
                setTimeout(() => {
                    systemStatus.classList.remove('show');
                }, 5000);
            }
        }

        // Function to show a custom modal for alerts
        function showModal(title, message) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('myModal').style.display = 'block';
        }

        // Function to close the custom modal
        window.closeModal = function() {
            document.getElementById('myModal').style.display = 'none';
        }

        // Main function to initialize the application
        async function initializeSystem() {
            try {
                console.log('Initializing system...');
                
                updateProgress(5, 'Membuka database lokal...');
                await openDatabase();
                
                // Try to load customer data from local storage first
                updateProgress(10, 'Memuat data pelanggan...');
                const storedData = await loadCustomerDataFromDatabase();
                if (storedData) {
                    csvData = storedData;
                } else {
                    // If no data is stored, load from the hardcoded CSV
                    await loadCSVData();
                }

                updateProgress(15, 'Memeriksa indeks PDF lokal...');
                const hasValidPdfCache = await loadIndexFromDatabase();

                if (hasValidPdfCache) {
                    // If a valid PDF cache exists, proceed
                    document.getElementById('initTitle').textContent = 'Memuat dari Database Lokal';
                    document.getElementById('initSubtext').textContent = 'Menggunakan data yang sudah tersimpan...';
                    updateProgress(90, 'Mempersiapkan sistem...');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    updateProgress(100, 'Sistem siap!');

                    setTimeout(() => {
                        document.getElementById('initOverlay').style.display = 'none';
                        isSystemReady = true;
                        showSystemStatus(`⚡ Sistem siap! Menggunakan database lokal dengan ${textIndex.size} entri pencarian.`, 'cached');
                    }, 1000);
                } else {
                    // If no valid PDF cache, perform a full indexing
                    document.getElementById('firstTimeNotice').style.display = 'block';
                    document.getElementById('initTitle').textContent = 'Membangun Database Lokal';
                    document.getElementById('initSubtext').textContent = 'Ini hanya dilakukan sekali untuk kunjungan pertama...';
                    await performFullIndexing();
                }

            } catch (error) {
                console.error('Error during initialization:', error);
                updateProgress(100, 'Error inisialisasi');
                setTimeout(() => {
                    document.getElementById('initOverlay').style.display = 'none';
                    showSystemStatus('❌ Terjadi error saat inisialisasi. Beberapa fitur mungkin tidak berfungsi optimal.', 'error');
                }, 2000);
            }
        }

        /**
         * Saves comment and location to the in-memory CSV data and then persists it to IndexedDB.
         * This replaces the old Firebase functionality.
         */
        window.saveCommentAndLocation = async () => {
            if (!searchIdpel) {
                showModal('Peringatan', 'Silakan cari pelanggan terlebih dahulu.');
                return;
            }

            if (isSaving) {
                showModal('Peringatan', 'Proses penyimpanan sedang berlangsung.');
                return;
            }
            isSaving = true;
            
            const comment = document.getElementById('commentInput').value;
            const statusElement = document.getElementById('locationStatus');
            statusElement.textContent = 'Mencari lokasi...';

            if (!navigator.geolocation) {
                showModal('Error', 'Geolocation tidak didukung oleh browser Anda.');
                statusElement.textContent = 'Geolocation tidak didukung.';
                isSaving = false;
                return;
            }

            navigator.geolocation.getCurrentPosition(async (position) => {
                const { latitude, longitude } = position.coords;
                const locationString = `Lat: ${latitude.toFixed(6)}, Lon: ${longitude.toFixed(6)}`;
                
                // Find and update the customer data in the in-memory CSV array
                const customerIndex = csvData.findIndex(item => item.IDPEL === searchIdpel);
                if (customerIndex > -1) {
                    csvData[customerIndex].Komentar = comment;
                    csvData[customerIndex].Lokasi = locationString;
                    
                    try {
                        await saveCustomerDataToDatabase(csvData);
                        statusElement.textContent = 'Data pelanggan berhasil diperbarui secara lokal!';
                    } catch (e) {
                        console.error("Error saving data to IndexedDB: ", e);
                        statusElement.textContent = 'Error: Gagal menyimpan data.';
                    }
                    
                    // Re-render the results to show the updated data
                    const currentResults = csvData.filter(item => item.IDPEL === searchIdpel);
                    displayResults(currentResults);

                } else {
                    statusElement.textContent = 'Error: Pelanggan tidak ditemukan dalam data.';
                }
                isSaving = false;
            }, (error) => {
                console.error("Geolocation error: ", error);
                statusElement.textContent = 'Error: Gagal mendapatkan lokasi.';
                showModal('Error', 'Gagal mendapatkan lokasi. Pastikan Anda mengizinkan akses lokasi.');
                isSaving = false;
            });
        };
        
        // Performs a full re-indexing of all PDF files
        async function performFullIndexing() {
            console.log('Performing full indexing...');
            
            updateProgress(15, 'Memuat data CSV...');
            await loadCSVData();
            
            const progressPerPDF = 75 / availablePDFs.length;
            
            for (let i = 0; i < availablePDFs.length; i++) {
                const pdfInfo = availablePDFs[i];
                updateProgress(20 + (i * progressPerPDF), `Memuat dan mengindex ${pdfInfo.name}...`);
                
                try {
                    // Use the base64 string directly
                    const loadingTask = pdfjsLib.getDocument({data: atob(pdfInfo.base64)});
                    const pdf = await loadingTask.promise;
                    
                    pdfDatabase.set(pdfInfo.id, {
                        pdf: pdf,
                        info: pdfInfo,
                        totalPages: pdf.numPages
                    });
                    
                    await indexPDFText(pdf, pdfInfo);
                    
                    updateProgress(20 + ((i + 1) * progressPerPDF), `Selesai mengindex ${pdfInfo.name}`);
                    
                } catch (error) {
                    console.error(`Error loading ${pdfInfo.name}:`, error);
                }
            }
            
            updateProgress(95, 'Menyimpan ke database lokal...');
            
            await saveIndexToDatabase(textIndex);
            updateDatabaseInfo(Date.now());
            
            updateProgress(100, 'Sistem siap!');
            
            setTimeout(() => {
                document.getElementById('initOverlay').style.display = 'none';
                isSystemReady = true;
                showSystemStatus(`✅ Sistem siap! Database lokal berisi ${textIndex.size} entri pencarian dari ${availablePDFs.length} file PDF.`);
            }, 1000);
        }
        
        // Indexes the text content of a single PDF document
        async function indexPDFText(pdf, pdfInfo) {
            const totalPages = pdf.numPages;
            
            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                try {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    
                    const indexKey = `${pdfInfo.id}_page_${pageNum}`;
                    textIndex.set(indexKey, {
                        pdfId: pdfInfo.id,
                        pdfInfo: pdfInfo,
                        pageNumber: pageNum,
                        text: pageText.toLowerCase(),
                        originalText: pageText,
                        textItems: textContent.items
                    });
                    
                } catch (error) {
                    console.error(`Error indexing page ${pageNum} of ${pdfInfo.name}:`, error);
                }
            }
        }
        
        // Forces a refresh of the IndexedDB database
        async function refreshDatabase() {
            showModal('Konfirmasi', 'Apakah Anda yakin ingin me-refresh database? Proses ini akan memakan waktu beberapa menit.');
            
            // Note: A real app would need a confirmation handler here.
            // For this example, we proceed immediately after the modal is shown.
            document.getElementById('initOverlay').style.display = 'flex';
            document.getElementById('initTitle').textContent = 'Me-refresh Database';
            document.getElementById('initSubtext').textContent = 'Membangun ulang database lokal...';
            document.getElementById('firstTimeNotice').style.display = 'none';
            
            isSystemReady = false;
            textIndex.clear();
            pdfDatabase.clear();
            
            await performFullIndexing();
        }
        
        // Performs an instant search on the in-memory index
        function instantSearch(searchTerm) {
            const results = [];
            const searchTermLower = searchTerm.toLowerCase();
            
            for (const [key, indexEntry] of textIndex.entries()) {
                if (indexEntry.text.includes(searchTermLower)) {
                    results.push(indexEntry);
                }
            }
            
            return results;
        }
        
        // Toggles the display between search input and "search again" button
        function toggleSearchDisplay(showResults = false) {
            const searchContainer = document.getElementById('searchContainer');
            const searchAgainContainer = document.getElementById('searchAgainContainer');
            
            if (showResults) {
                searchContainer.classList.add('hidden');
                searchAgainContainer.classList.add('show');
                hasSearchResults = true;
            } else {
                searchContainer.classList.remove('hidden');
                searchAgainContainer.classList.remove('show');
                hasSearchResults = false;
            }
        }
        
        // Resets the UI to the initial search state
        function searchAgain() {
            searchIdpel = '';
            foundPages = [];
            currentPdf = null;
            hasSearchResults = false;
            
            document.getElementById('searchInput').value = '';
            
            document.getElementById('resultsContainer').innerHTML = '';
            
            document.getElementById('pdfContainer').style.display = 'none';
            document.getElementById('pdfViewer').innerHTML = '';
            
            toggleSearchDisplay(false);
            
            document.getElementById('searchInput').focus();

            // Hide the location section when searching again
            document.getElementById('locationSection').classList.add('hidden');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Main function to perform a search on the CSV data
        function performSearch(keyword) {
            if (keyword.trim() === "") {
                showModal('Peringatan', 'Silakan masukkan kata kunci pencarian.');
                return;
            }
            
            if (!isSystemReady) {
                showModal('Peringatan', 'Sistem masih dalam proses inisialisasi. Mohon tunggu sebentar...');
                return;
            }
            
            document.getElementById('searchInput').value = '';
            document.getElementById('searchInput').blur();
            
            keyword = keyword.toLowerCase();
            const results = csvData.filter(item => {
                for (const key in item) {
                    if (item[key].toLowerCase().includes(keyword)) {
                        return true;
                    }
                }
                return false;
            });
            
            displayResults(results);
            
            if (results.length > 0) {
                toggleSearchDisplay(true);
            }
        }
        
        // Displays the search results from the CSV data
        function displayResults(results) {
            const resultsContainer = document.getElementById('resultsContainer');
            const locationSection = document.getElementById('locationSection');
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="no-results">Tidak ditemukan data yang sesuai</div>';
                document.getElementById('pdfContainer').style.display = 'none';
                locationSection.classList.add('hidden'); // Hide the section if no results
                return;
            }
            
            // Show the location section because results were found
            locationSection.classList.remove('hidden');

            let html = `<div class="results-count">📊 Ditemukan ${results.length} data:</div>`;
            
            results.forEach((item, index) => {
                html += '<div class="result-item">';
                
                for (const key in item) {
                    if (key === 'IDPEL') {
                        html += `<div class="idpel"><strong>${key}:</strong> ${item[key]}</div>`;
                        // Set the IDPEL for the save function
                        searchIdpel = item[key];
                    } else if (item[key]) { // Only display if the value is not empty
                        html += `<p><strong>${key}:</strong> ${item[key]}</p>`;
                    }
                }
                
                if (item.IDPEL && item.IDPEL.trim() !== '') {
                    html += `<button class="show-program-btn instant" onclick="showProgram('${item.IDPEL}')">
                        📄 Tampilkan Program<br>IDPEL: ${item.IDPEL}
                    </button>`;
                }
                
                html += '</div>';
            });
            
            resultsContainer.innerHTML = html;
        }
        
        // Loads CSV data from a file
        async function loadCSVData() {
            try {
                // Use the hardcoded CSV text instead of fetching a file
                const csvTextToParse = defaultCsvText;
                
                const lines = csvTextToParse.split('\n');
                const headers = lines[0].split(',').map(h => h.trim());
                
                for (let i = 1; i < lines.length; i++) {
                    const currentLine = lines[i].split(',');
                    if (currentLine.length === headers.length && currentLine[0].trim() !== '') {
                        const obj = {};
                        for (let j = 0; j < headers.length; j++) {
                            obj[headers[j]] = currentLine[j].trim();
                        }
                        csvData.push(obj);
                    }
                }
                console.log('Data CSV dimuat:', csvData.length, 'records');
            } catch (error) {
                console.error('Gagal memuat file CSV:', error);
                throw error;
            }
        }
        
        // Displays the PDF pages containing the IDPEL
        async function showProgram(idpel) {
            const pdfContainer = document.getElementById('pdfContainer');
            const pdfViewer = document.getElementById('pdfViewer');
            
            if (!isSystemReady) {
                showModal('Peringatan', 'Sistem masih dalam proses inisialisasi. Mohon tunggu sebentar...');
                return;
            }
            
            searchIdpel = idpel;
            
            pdfContainer.style.display = 'block';
            pdfContainer.scrollIntoView({ behavior: 'smooth' });
            
            const searchResults = instantSearch(idpel);
            
            if (searchResults.length === 0) {
                pdfViewer.innerHTML = `
                    <div class="no-results">
                        🔍 IDPEL "${idpel}" tidak ditemukan dalam database PDF
                    </div>
                `;
                return;
            }
            
            pdfViewer.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">⚡ Memuat hasil pencarian instan...</div>';
            
            await renderFoundPages(searchResults);
        }
        
        // Renders the found PDF pages to the UI
        async function renderFoundPages(searchResults) {
            const pdfViewer = document.getElementById('pdfViewer');
            pdfViewer.innerHTML = '';
            
            const groupedResults = new Map();
            for (const result of searchResults) {
                if (!groupedResults.has(result.pdfId)) {
                    groupedResults.set(result.pdfId, []);
                }
                groupedResults.get(result.pdfId).push(result);
            }
            
            for (const [pdfId, pages] of groupedResults.entries()) {
                let pdfData = pdfDatabase.get(pdfId);
                
                if (!pdfData) {
                    const pdfInfo = availablePDFs.find(pdf => pdf.id === pdfId);
                    if (pdfInfo) {
                        try {
                            const loadingTask = pdfjsLib.getDocument({data: atob(pdfInfo.base64)});
                            const pdf = await loadingTask.promise;
                            pdfData = {
                                pdf: pdf,
                                info: pdfInfo,
                                totalPages: pdf.numPages
                            };
                            pdfDatabase.set(pdfId, pdfData);
                        } catch (error) {
                            console.error(`Error loading PDF ${pdfInfo.name}:`, error);
                            continue;
                        }
                    }
                }
                
                if (!pdfData) continue;
                
                for (const pageResult of pages) {
                    try {
                        const page = await pdfData.pdf.getPage(pageResult.pageNumber);
                        
                        const container = pdfViewer;
                        const containerWidth = container.clientWidth - 40;
                        const baseViewport = page.getViewport({ scale: 1 });
                        const scale = containerWidth / baseViewport.width;
                        
                        const canvas = await renderPageToCanvas(page, scale);
                        
                        const pageDiv = document.createElement('div');
                        pageDiv.className = 'pdf-page';
                        pageDiv.appendChild(canvas);
                        
                        await highlightTextInPage(page, pageDiv, page.getViewport({ scale: scale }), searchIdpel);
                        
                        pdfViewer.appendChild(pageDiv);
                        
                    } catch (error) {
                        console.error(`Error rendering page ${pageResult.pageNumber}:`, error);
                    }
                }
            }
        }
        
        // Renders a single PDF page to a canvas
        async function renderPageToCanvas(page, scale) {
            const scaledViewport = page.getViewport({ scale: scale });
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            const outputScale = devicePixelRatio;
            canvas.width = Math.floor(scaledViewport.width * outputScale);
            canvas.height = Math.floor(scaledViewport.height * outputScale);
            canvas.style.width = Math.floor(scaledViewport.width) + "px";
            canvas.style.height = Math.floor(scaledViewport.height) + "px";
            
            const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
            
            context.imageSmoothingEnabled = true;
            context.imageSmoothingQuality = 'high';
            
            canvas.className = 'pdf-canvas';
            
            const renderContext = {
                canvasContext: context,
                viewport: scaledViewport,
                transform: transform
            };
            
            await page.render(renderContext).promise;
            
            return canvas;
        }
        
        // Highlights text on a rendered PDF page
        async function highlightTextInPage(page, pageDiv, viewport, searchText) {
            try {
                const textContent = await page.getTextContent();
                
                textContent.items.forEach(item => {
                    if (item.str.toLowerCase().includes(searchText.toLowerCase())) {
                        const highlight = document.createElement('div');
                        highlight.className = 'highlight-overlay';
                        
                        const transform = pdfjsLib.Util.transform(viewport.transform, item.transform);
                        const left = transform[4];
                        const top = viewport.height - transform[5] - item.height;
                        
                        highlight.style.left = left + 'px';
                        highlight.style.top = top + 'px';
                        highlight.style.width = item.width + 'px';
                        highlight.style.height = item.height + 'px';
                        
                        pageDiv.appendChild(highlight);
                    }
                });
            } catch (error) {
                console.error('Error highlighting text:', error);
            }
        }
        
        // Event listener to start the initialization process
        document.addEventListener('DOMContentLoaded', () => {
            initializeSystem();
            
            document.getElementById('searchButton').addEventListener('click', () => {
                const keyword = document.getElementById('searchInput').value;
                performSearch(keyword);
            });
            
            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const keyword = document.getElementById('searchInput').value;
                    performSearch(keyword);
                }
            });
            
            document.getElementById('searchAgainBtn').addEventListener('click', searchAgain);
        });
    </script>
</body>
</html>
